# ⭐CSS

### 01. 盒模型

`box-sizing： content-box / border-box  `

- 标准盒模型

  width /height 属性 只包括内容的宽和高

- IE 盒模型

  width / height 属性 包括内容，内边距和边框

### 02. position

- static：默认值
- relative：相对元素自身位置
- absolute：相对最近（relative/absolute/fixed）的祖先元素，找不到则相对于根元素。
- fixed：相对视口（当祖先元素具有`transform`属性且不为none时，就会相对于祖先元素指定坐标，而不是浏览器窗口）
- absolute/fixed 脱离文档流
- sticky：粘性定位，当元素在可视范围内为 relative，超出则为 fixed，必须指定 top 、left、right、bottom 其中一个才生效。

### 03. 伪类/伪元素

- 伪类选择器：选择处于特定状态的元素的选择器，`:hover` 
- 伪元素选择器：在选定元素的特定位置插入额外的元素或样式， :`:before` / `::first-line`



### 04.选择器优先级

- !important 
-  内联样式 
- ID 选择器 
- 类选择器 =  伪类选择器 = 属性选择器
- 标签选择器 = 伪元素选择器

```css
// 属性选择器
a[href="https://example.org"] {
  color: green;
}
```



### 05. 清除浮动

父元素不写高度时，子元素写了浮动后，脱离文档流，父元素会发生高度塌陷（造成父元素高度为 0）

**解决高度塌陷：**

- 为父元素设置 `overflow:hidden` 属性，缺点：会隐藏超出的内容

- 添加一个 `clear:both` 的块级元素，缺点：多余元素

- 父元素也浮动，缺点：产生新的浮动影响

- 完美方案：**父级末尾添加伪元素**

  ```css
  父元素::after{ content:""; display:block; clear:both; height:0;}
  ```



### 06.BFC

块级格式化上下文；独立的渲染区域；只有块级元素参与，它规定了内部的块级元素如何布局；

**布局规则**：

- BFC 内部不影响外部，外部也不影响内部
- 内部的 Box 会在垂直方向，一个接一个地放置
- Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠，水平方向的margin不会重叠
- 计算 BFC 的高度时，浮动元素计算在内



**形成BFC**

- 根元素

- overflow 除了 visible 以外的值 (hidden、auto、scroll)

- float：left/right，不是none

- position：abolute/fixed

- display：inline-block、flex、grid、table-cell



**应用**

- 阻止外边距重叠

- 包含内部浮动（防止高度塌陷）

- 排除外部浮动（左右，防止覆盖）



**IFC**

- display 属性为 inline, inline-block 会形成 行内格式化上下文

- 形成：块级元素中仅包含行内元素

- 应用：

  - 水平居中： `text-align：center`

  - 垂直居中：`vertical-align: middle`



# ⭐JavaScript

### 01.类型判断

- 原始数据类类型：Undefined、Null、Boolean、Number、String、Symbol、BigInt
- 引用数据类型：Object

1. **typeof**
- undefined / string / number / boolean/ symbol(ES6) / bigint(ES2020)
- function(函数对象) 和 object(其他对象或 null)
> 在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0，由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签是 0，typeof null 也因此返回 "object"。


2. **instanceof**
- 对基本数据类型不起作用，可以判断引用数据类型，判断对象是否为构造函数的实例，原理是判断对象的原型链中是否存在构造函数的原型对象。
```js
function myInstanceOf(obj, Type) {
  let proto = Object.getPrototypeOf(obj)

  while(proto) {
    if (proto === Type.prototype) {
      return true
    }
    proto = Object.getPrototypeOf(proto)
  }
  return false
}
```

3. **constructor**
- 原理是通过访问对象实例的 constructor 属性访问对应的构造函数
- undefined 和 null 没有 contructor 属性
- 容易伪造，不适合做类型判断

- **跨窗口**，同窗口下的内置对象是不同的实例 instanceof 和 constructor 都会出现问题


4. **Object.prototype.toString.call()**
- 不能检测非原生构造函数的构造函数名
- `Object.prototype.toString.call(value).slice(8, -1)`

如果要判断的是基本数据类型或 JavaScript内置对象，使用 toString；如果要判断的是自定义类型，可以使用`instanceof`。

#### 判断数组

- `Object.prototype.toString.call(arr).slice(8,-1) === 'Array'`
- `arr instanceof Array`
- `Array.isArray(arr)`
- `Array.prototype.isPrototypeOf(arr)` /` obj.__proto__ === Array.prototype`



### 02.浮点数精度

- 在 JavaScript 中, Number 是一种 定义为 64 位双精度浮点型 (IEEE 754)的数字数据类型
- 64位 = 1位符号位 + 11位指数位 + 52位小数位
- 十进制的小数转为二进制时采用的方法时**乘二取整法**，可能会出现无限循环的二进制数。

**解决精度丢失**

- 展示数据时，toPrecision 返回一个指定精度的数字。 toFixed 返回指定小数位数 (四舍五入是不确定)
- 计算时可以先转为整数，先扩大再缩小
```jsx
/**
 * 精确加法
 */
function add(num1, num2) {
  const num1Digits = (num1.toString().split('.')[1] || '').length;
  const num2Digits = (num2.toString().split('.')[1] || '').length;
  const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));
  return (num1 * baseNum + num2 * baseNum) / baseNum;

```

- 或者使用类库计算如 number-precision.js、Math.js、BigDecimal.js

### 03.类型转换
`==`

- null == undefined 
- 更倾向number，一方存在 number ，则都转为 number

`+`

- 更倾向转为string

转为string时，"undefined","null","true"/ "false"
转为 number 时, null 为 0, undefined 为NaN, boolean为1/0，symbol 报错

对象会按优先级调用 [Symbol.toPrimitive] / valueof / toString 方法


### 04.Object.is

- 使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。
- 使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。
- 使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。
```jsx
 Object.is = function(x, y) {
    if (x === y) { // Steps 1-5, 7-10
      // +0不等于-0
      return x !== 0 || 1 / x === 1 / y;
      // 相当于
      // if(x === 0){
      //   return  1 / x === 1 / y
      //  }
    } else { 
      // 针对 NaN 等于 NaN
      return x !== x && y !== y;
    }
  };
```

## 核心
### 01.变量提升和暂时性死区

- **变量提升**，是指在代码执行过程中，引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，变量的值是`undefined`。

- 但实际上变量和函数声明在代码里的位置是不会改变的，而且是在**编译阶段 **被 JS 引擎放入内存中的，存在执行上下文的变量环境中。

- 暂时性死区：在用 let/const 命令**声明变量之前**，该变量都是不可用的。这在语法上称为 “暂时性死区”（ temporal dead zone，简称 TDZ）
### 02.作用域
作用域控制着变量和函数的可见性和生命周期，是**声明时就决定**的，是词法作用域。分为：

- **全局作用域**中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。
- **函数作用域**就是在函数内部定义的变量或者函数，定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。
- **块级作用域**就是使用一对大括号包裹的一段代码，块级作用域就是通过词法环境的栈结构来实现的。使用let/const 使用，{ }内部变量不会覆盖外部的

### 03.闭包

- 闭包的形成源于两点**词法作用域**和**函数**可以作为值传递
- 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数在当前词法作用域之外执行。

- 闭包和作用域链相关，函数内部是可以读取外部作用域的变量的，但是从函数外部不可以之间读取内部的局部变量的；可以内部定义一个函数读取局部变量，并返回一个函数出来，这个被引用的变量会始终保存在内存中。（**私有化数据**）

- 从 JS 引擎角度，JS 遇到内部函数，对其进行快速的词法扫描，**发现内部函数引用了外部函数的变量**，会在堆空间创建 closure(外部函数) 对象。

### 04.执行上下文
执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。
分为：

- 全局执行上下文
- 函数执行上下文
- Eval 函数执行上下文

![](https://cdn.nlark.com/yuque/0/2021/png/338495/1626710954144-44541328-f268-4ba6-8494-38f2710fefa2.png?x-oss-process=image%2Fresize%2Cw_610%2Climit_0#crop=0&crop=0&crop=1&crop=1&from=url&height=256&id=GowyI&margin=%5Bobject%20Object%5D&originHeight=329&originWidth=610&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=474)

- 变量环境是用来登记 var function变量声明，词法环境是用来登记let const class 等变量声明。**块级作用域就是通过词法环境的栈结构来实现的**，而变量提升是通过变量环境来实现。

- 执行上下文是代码执行之前创建的。this 的指向是执行时确定的。

### 05.作用域链

- 作用域链就是将一个个作用域串起来，实现变量查找的路径。

- 在 JavaScript 执行过程中，其作用域链是由词法作用域决定的。** 词法作用域**就是指查找作用域的顺序是按照函数定义时的位置来决定的 ，所以词法作用域是**静态的作用域。**




- 每个执行上下文的**变量环境中，都包含了一个外部引用**，用来指向外部的执行上下文，我们把这个外部引用称为**outer**

### 06.this
this 是和执行上下文绑定的，每个执行上下文都有一个this

1. 当函数作为对象的方法调用时，函数中的 this 就是该对象；
1. 当函数被直接调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象；
1. 箭头函数继承外层函数的 this 值
1. 使用call/apply/bind指定this

### 05.原型链

- **prototype（原型对象）**是构造函数的属性，**__proto__**是任何对象的属性，指向该对象的构造函数的**prototype。**
- prototype 有 constructor 属性，指向构造函数
- **构造函数**也是对象，构造函数的__proto__的属性指向构造函数 **Function() **的 **prototype**
- **prototype**对象，其_**_proto__**属性指向构造函数**Obejct()**的**prototype**(最终指向null)，

### 06.继承的方式
![image.png](https://cdn.nlark.com/yuque/0/2021/png/338495/1625043301872-32a96c0d-9108-4e2c-9563-5cc933b9355a.png#clientId=ue67dbe16-192a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uec2a04dd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=713&originWidth=2021&originalType=url&ratio=1&rotation=0&showTitle=false&size=129636&status=done&style=none&taskId=u8a5af54d-84f2-4bf1-9e35-984714f59e6&title=)

1. 原型链继承：` Child.prototype = new Parent()`;所有实例对象共享一个原型对象，子类创建实例时没法传参
1. 构造函数继承：`function Child () { Parent.call(this); }`，不能继承父类原型属性或者方法
1. 组合继承： 构造函数多调用了一次
```jsx
function Child (name, age) {
    Parent.call(this, name); //  第二次调用 Parent()
    this.age = age;
}

Child.prototype = new Parent(); // // 第一次调用 Parent()
Child.prototype.constructor = Child; //// 手动挂上构造器，指向自己的构造函数
```

4. 原型式继承： 基于已有的对象来创建新的对象，使用Object.create方法，将传入对象作为返回对象的原型对象。`let person4 = Object.create(parent4);`，缺点与原型链继承相同
4. 寄生式继承：对原型式继承获得的对象，再进行扩展。缺点是没有办法实现函数的复用
4. 寄生组合式继承：
```jsx
function Child (name, age) {
    Parent.call(this, name); // 调用 Parent()
    this.age = age;
}


funtion inherit(Child,Parent){
  // 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程
  Child.prototype = Object.create(Parent.prototype); 
  Child.prototype.constructor = Child; //// 手动挂上构造器，指向自己的构造函数
  
  // 子类继承父类的静态属性方法
  Object.setPrototypeOf(subClass, superClass) // __proto__
}

```
## 异步
### 01.事件循环
JS 是单线程的语言，只有一个执行栈，先执行当前任务，遇到异步事件就放入任务队列中，分为宏任务和微任务，当前宏任务执行完会处理所有的微任务，再从宏任务队列中取一个开始下一个宏任务。

- 渲染是下一个宏任务执行前 [https://zhuanlan.zhihu.com/p/78113300](https://zhuanlan.zhihu.com/p/78113300)

![image.png](https://cdn.nlark.com/yuque/0/2022/png/338495/1654402275546-74fadbb4-590b-42cb-9079-9df66ae710ed.png#clientId=u808fbc64-67e7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=345&id=u7bc212b8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=740&originWidth=392&originalType=url&ratio=1&rotation=0&showTitle=false&size=76431&status=done&style=none&taskId=u2d5d8d16-4b64-40ce-9202-43806adf8d8&title=&width=183)

宏任务：script标签 / 交互事件

-  setTimeout() / setInterval() /requestAnimationFrame() /  **Node**: setImmediate（）

微任务：

- Promise()  / MutationObserver() / queueMicrotask() /  **Node**: process.nextTick()


Node:

- Node11以后，每执行完一 个timers  类回调，例如 setTimeout ,setImmediate 之后，都会把微任务给执行掉（promise等）



## ES6
### 01.var/let/const
| **区别** | **var** | **let** | **const** |
| --- | --- | --- | --- |
| 是否有块级作用域 | × | √ | √ |
| 是否存在变量提升 | √ | × | × |
| 是否添加全局属性 | √ | × | × |
| 能否重复声明变量 | √ | × | × |
| 是否存在暂时性死区 | × | √ | √ |
| 是否必须设置初始值 | × | × | √ |
| 能否改变指针指向 | √ | √ | × |




### 02.箭头函数

- 箭头函数不会创建自己的 this，从上一层作用域继承 this
- call()、apply()、bind() 等方法不能改变箭头函数中 this 的指向
- 没有 arguments，没有 prototype，不能 new
- 不能使用 yield命令，箭头函数不能用作 Generator 函数。


### 03.展开语法/剩余参数
剩余语法(Rest syntax) 看起来和展开语法(Spread syntax)完全相同，不同点在于, 展开语法用于解构数组和对象。从某种意义上说，剩余语法与展开语法是相反的：**展开**语法将数组展开为其中的各个元素，而剩余语法则是将多个元素**收集**起来。

- 在数组或函数参数中使用展开语法时, 该语法只能用于可迭代对象
```jsx
console.log(...[1, 2, 3]) // spread
```
> ES2018 将这个运算符[引入](https://github.com/sebmarkbage/ecmascript-rest-spread)了对象

```jsx
let n = { x, y, ...z }; // spread

let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }; //rest
```
### 04.解构赋值
通过**解构赋值, **可以将属性/值从对象/数组中取出,赋值给其他变量。
```jsx
var o = {p: 42, q: true};
var {p, q} = o;

var foo = ["one", "two", "three"];
var [one, two, three] = foo;
```

### 什么是弱引用，WeakSet/WeakMap

- WeakSet的成员要求是对象，WeakMap的键要求是对象。
- WeakSet 中的对象都是弱引用，如果WeakSet中的某个对象不可达（引用置为null）了，WeakSet中的该对象会被回收掉。
- WeakMap 实例仅有has()、set()、get()、delete()操作方法，没有size属性以及keys()、values()、entries()方法，所以不能获取其所有键值，也就不能迭代。
- WeakSet/WeakMap 没有部署 Iterator接口，所以不能用f or...of 遍历。因为size取决于垃圾回收机制。
- 场景
   - WeakSet：保存dom节点
   - WeakMap： 给dom添加处理函数
## 其他
### 01.类数组
一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。
```jsx
var arrayLike = {
    0: 'name',
    1: 'age',
    2: 'sex',
    length: 3
}
```

- 调用数组方法 Array.prototype.xxx.call(arrayLike，...)
- 转成数组
   - Array.from(arrayLike);
   - Array.prototype.slice.call(arrayLike);
   - Array.prototype.splice.call(arrayLike, 0);
   - Array.prototype.concat.apply([], arrayLike);

### 02.严格模式
```jsx
'use strict';
```

- 全局变量必须显式声明
- 禁用 with
- 严格模式下，eval 语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。
- 不能用delete
- 禁止 this 关键字指向全局对象
- 对象不能有重名的属性
```jsx
var myIterable = {}
myIterable[Symbol.iterator] = function* () {
    yield 1;
    yield 2;
    yield 3;
};
[...myIterable] // [1, 2, 3]
```

### 03.IIFE
立即调用函数表达式
```jsx
(function () {
   //
})();
```
立即执行函数，第一个括号里是匿名函数，拥有独立的词法作用域，把函数声明变成表达式。
第二个括号是执行传参

### 04.语句和表达式

- 语句：语句分为声明语句、流程控制语句和其他语句。
- 表达式：返回一个值，有副作用的（比如赋值）和单纯计算求值
```jsx
// 表达式
myvar 
x=7 // 赋值
3+4 // 求值

// 语句
var a;


// 函数表达式
function () { }


```

- 函数表达式，允许省略函数名
```jsx
let sayHi = function() {
  alert( "Hello" );
};
```

### 05.函数式编程

- 函数是一等公民，可以作为函数的入参和返回值
- 声明式编程 map/filter等
- 纯函数：无状态和无副作用，相同的输入永远得到相同的输出

**柯里化：**将一个多参函数，转换成一个依次调用的单参函数。
柯里化函数会接收一些参数，然后不会立即求值，而是继续返回一个新函数，将传入的参数通过闭包的形式保存，等到被真正求值的时候,，再进行求值。

**偏函数**：则是固定一个函数的一个或多个参数，也就是将一个 n 元函数转换成一个 n - x 元函数。

compose: 函数组合的目的是将多个函数组合成一个函数
```jsx
const compose = (f, g) => x => f(g(x))
```

### 06.哪些操作会造成内存泄漏

- 全局变量，这些数据只有在窗口关闭或重新刷新页面时才会被释放
- 不合理使用的闭包，导致变量一直存在内存中
- 没有清理的 DOM 元素引用
- 定时器 clearTimeout
- 事件监听  removeEventListener

**避免：**

- 减少不必要的全局变量，使⽤严格模式避免意外创建全局变量。
- 在你使⽤完数据后，及时解除引⽤（闭包中的变量，dom引⽤，定时器清除）。

### 实现sizeOf函数, 计算传入的对象所占的Bytes
```javascript
function sizeOf(o){
  const type = typeof object
  switch(type){
    case 'string': return o.length*2
    case 'boolean'  return 4
    case 'number' return 8
  }
}
```
## 
### for循环问题

- var for里面定义的变量渗透到了外部
- let 块级作用域，每次循环重新声明一个变量

## 打印题
### ['1', '2', '3'].map(parseInt)
`[1, NaN, NaN]`
```jsx
['1', '2', '3'].map(parseInt) // [1, NaN, NaN]

const arr = ['1', '2', '3']
const res = arr.map((s, index) => {
    return parseInt(s, index)
})

parseInt('1', 0) // 1 ，radix === 0 按 10 进制处理
parseInt('2', 1) // NaN ，radix === 1 非法（不在 2-36 之内）
parseInt('3', 2) // NaN ，2 进制中没有 3
```

# ⭐HTML/DOM/网络/浏览器 
### offsetHeight-scrollHeight-clientHeight-区别

- style.width的返回值是字符串，并且带有单位
- offsetHeight/offsetWidth ：border + padding + content
- clientHeight/clientWidth ：padding + content
- scrollHeight/scrollWidth ：padding + 实际内容的尺寸
- scrollTop/scrollLeft : DOM 内部元素滚动的距离

![](https://cdn.nlark.com/yuque/0/2021/png/338495/1620556246492-47ff64d3-9e0b-4531-a259-77eced186322.png?x-oss-process=image%2Fresize%2Cw_937%2Climit_0#crop=0&crop=0&crop=1&crop=1&from=url&id=wnd35&margin=%5Bobject%20Object%5D&originHeight=424&originWidth=937&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

- window.innerHeight：**可视区域高度**
- document.documentElement.clientHeight：**可视区域高度，**不包含滚动条
- document.documentElement.scrollHeight：html元素高度
- document.body.clientHeight：body元素高度

### property 和 attribute区别

- property：每个DOM节点都是 JS 对象，操作 property 是 JS 范畴的
- attribute：是DOM上的属性

两者之间的区别是：

- 自定义的 property 与 attribute 不同步,不相等
- 非自定义的 DOM property 与 attributes 是有条件同步的（如 value不会同步）

### async 和 defer 区别

- 两个都是异步加载 JS 脚本，不阻塞 html 解析
-  defer 是先加载，等到dom解析完，在DOMContentLoaded事件之前执行脚本
- async 是加载完立即执行
- type="module" 等同于defer

### href 和 src 区别

- href 用于建立当前页面与引用资源之间的关系（链接）如 a / link，
-  src 则会替换当前标签，如 img / script/ iframe

### CSS会阻塞渲染吗

- CSS 不会阻塞 DOM 解析（link在head中）
- CSS 会阻塞 DOM 树的渲染（阻塞render tree的形成）
- 会阻塞后面的 JS 的执行（JS可以更改DOM样式）

### HTML5 新特性

- 语义化标签
- canvas/svg
- localStorage / sessionStorage
- websocket
- history api   @路由
   - puhState / replaceState方法
   - popstate事件，上述两个方法不会触发
- 媒体/表单/定位相关

### HTTP/1.1长连接 和 HTTP/2.0多路复用?

- HTTP/1.1：同⼀时间⼀个TCP连接只能处理⼀个请求, 采⽤⼀问⼀答的形式, 上⼀个请求响应后才能处理下⼀个请求. 由于浏览器最⼤TCP连接数的限制, 所以有了最⼤并发请求数的限制.
- HTTP/2.0：同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接⽽带来的延时和内存消耗。单个连接上可以并⾏交错的请求和响应，之间互不干扰。

那为什么HTTP/1.1不能实现多路复⽤?

- HTTP/2是基于⼆进制“帧”的协议，HTTP/1.1是基于(报文)“⽂本分割”解析的协议。
- HTTP1.1的报⽂结构中, 服务器需要不断的读⼊字节，直到遇到换⾏符, 或者说⼀个空⽩⾏. 处理顺序是串⾏的, ⼀个请求和⼀个响应需要通过⼀问⼀答的形式才能对应起来。
- HTTP2.0中，有两个⾮常重要的概念，分别是帧（frame）和流（stream）。帧代表着最⼩的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。
- 多路复⽤，就是在⼀个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极⼤的提⾼传输性能。
### 
### token会劫持的问题

- token 是为了防止 csrf 攻击的，因为浏览器会自动携带同域 Cookie 发送请求。
- CSRF 的过程：
   - 用户登录了 `a.com` ，有了 cookie
   - 黑客引诱用户访问 `b.com` 网页，偷偷让用户访问了 `a.com/api/xxx`（干某件事）
   - `a.com` api 接口收到请求 cookie ，误以为是真实用户的请求，就受理了

### 浏览器存储方式

-  **Cookie**：4K，用于HTTP请求头，同源，每个域名Cookie数量不超过20个
   - 可设置有效期（Expires/Max-Age）
   - Secure 标记为只能通过HTTPS发送
   - HttpOnly无法通过JS访问（ Document.cookie）
   - SameSite（none是可跨域携带，strict不可以）
   - Domain/Path 定义了 Cookie 的作用域
- 主要用于，会话状态管理，行为跟踪。
- 缺陷：空间小，网络请求会携带

**LocalStorage/SessionStorage**：5M

- SessionStorage：当前窗口关闭就失效了，多个同源页面不共享
- localStorage：永久保存，同源页面共享
- 缺点：空间小，只能存字符串

**IndexedDB**：用于客户端存储大量结构化数据，采用键值存储，接近NoSQL数据库，支持异步，理论上空间无限（250M上）


### 垃圾回收机制

- 堆
- 引用计数法/标记清除法（可达性分析）
- 代价假说，新生代，老年代
- 单线程-全停顿  v8做了一些优化，增量标记（利用浏览器空闲时间），惰性清理（写屏障），，并发并行，目的是减少堆主线程的影响

# ⭐Vue
### MVVM概念

1. Model模型层、View视图层、ViewModel：视图模型层，用来连接 Model 和 View
1. 通过双向数据绑定，数据驱动视图，视图响应改变数据。
1. Vue 可以看作是 MVVM 框架，Vue 实例的变量名用的是 vm (ViewModel 的缩写) ；但没有完全遵循 MVVM 模型，Vue 中可以通过 $ref 直接去操作视图，这一点上违背了 MVVM。



**双向绑定**

- v-model 是语法糖，默认情况下相当于 :value 和 @input，通常在表单项上使⽤ v-model ，也可以在⾃定义组件上使⽤
- v-model 只能去绑定一个遍历，使用. sync 可以实现多个变量的双向绑定 。 
```javascript
<!-- 使用.sync -->
<ChildComponent :title.sync="pageTitle" />
<!-- 是以下的简写: -->
<ChildComponent :title="pageTitle" @update:title="pageTitle = $event" />
 // 子组件触发更新
this.$emit('update:title', newValue)
  
```

- vue3 的 v-model 类似.sync 
```javascript
<ChildComponent v-model="pageTitle" />
!-- 是以下的简写: -->
<ChildComponent
  :modelValue="pageTitle"
  @update:modelValue="pageTitle = $event"
/>
  

<!-- 指定prop: -->
<ChildComponent v-model:title="pageTitle" />
<!-- 是以下的简写: -->
<ChildComponent :title="pageTitle" @update:title="pageTitle = $event" />
```


### Vue 生命周期

- 生命周期钩子就是回调函数而已，当创建组件实例的过程中会调用对应的钩子，钩子函数维护成数组的形式。
- 分为 组件的创建前后（beforeCreate/created）、挂载前后（beforeMount/mounted）、更新前后（before/beforeDestory）、销毁前后（beforeDestory/destroyed；v3:beforeUmounted/unmounted）
- keep-alive激活时（activated/deactivated）
- 捕获后代组件错误（errorCaptued）
- 父子组件，创建是自上而下，挂载是自下而上。

### v-if 和 v-for

- Vue2 中 for 比 if 的优先级高，如果放在一起使用，会遍历整个列表判断；推荐使用 computed 计算属性；
- Vue3 中 if 比 for 的优先级高。

### v-if 和 v-show

- v-if 如果条件不成立不会渲染当前指令所在节点的 dom 元素
- v-show是改变的元素的display: none
- 频繁切换的就用 v-show
### computed和watch

- computed 依赖响应式的数据产生新数据，具有缓存性，只有依赖的响应式数据变化时才会重新求值。
- watch 用来监听某个响应式数据的变化并执行对应的回调函数，是命令式的。

### 组件通信方式

- 父子组件 props / $emit - ~~$on~~/ $ref / $parent - $~~children~~/ $refs / $attrs - ~~$listeners~~
- 兄弟组件 $parent / $root / eventbus / vuex
- 跨层级关系 provide + inject / eventbus / vuex 

> 父组件向子组件传递的事件内部其实是使用`$on`实现的。


### 组件扩展方法

- mixins
```javascript
// 全局混⼊：将混⼊对象传⼊
Vue.mixin(mymixin)

// 局部混⼊：做数组项设置到mixins选项，仅作⽤于当前组件
const Comp = {
  mixins: [mymixin]
}
```

- slot  默认插槽/具名插槽/作用域插槽
- extends	(组件的继承，类似于mixins)
- 合并策略：
   - 同名钩子函数合到一个数组，混入的在前面
   - 为对象的选项，冲突以当前组件的为准
- 混入的数据和方法不好判断来源而且容易冲突，composition-api 利用独立的响应式模块方便使用响应式数据和编写独立的逻辑，更有利于逻辑抽离，方便可读性和可维护性。

### 组件data为什么必须是个函数？
每次使用组件时都会对组件进行实例化操作，并且调用 data 函数返回一个对象作为组件的数据源。这样可以保证多个组件间数据互不影响

### vue 响应式理解⭐

- Vue2中 对象使用 Object.defineProperty 对属性进行劫持，多层对象是递归实现劫持的；数组是通过重写数据的 7 个原型方法。就等在get的时候进行依赖收集，set的时候做出响应。
- 缺点：对象无法监听到新增和删除属性，需要使用$set/$delete；数组无法监听索引和长度变化。不支持Map/Set
- Vue3 使用 Proxy 对数据进行代理，实现懒代理，解决Vue2 的问题，性能更好

### 模板编译原理⭐

- 将 templete 解析成 AST语法树
-  对静态节点进行标记（diff可以优化，跳过静态节点）
- 生成代码，render函数

### 虚拟DOM的理解

- 虚拟DOM 就是用 JS 对象来描述真实的DOM，是一种抽象
- 直接操作 DOM 是有限制，如diff/clone，通过 JS 操作对象更方便；频繁的操作dom会引发重排和重绘，通过patch方法（diff）渲染的页面，可以减少dom 直接操作的次数。
- 实现跨平台，通过 vdom 可以渲染到不同的平台。

### key 的作用⭐

- key 是给每一个 vnode 的唯一 id，也是 diff 的一种优化策略，可以根据 key，找到对应的 old vnode 节点，减少更新 dom 的操作。
- 若不设置 key，就是undefined，渲染的元素列表时，会就地复用元素，如果元素有状态的情况下会造成渲染错误。
- 使用 index 作为 key，如果列表的顺序会发生变化，和不写 key 区别不大。


### diff⭐

- 首先 dom diff 是同层比较，不考虑跨层的情况
- 先比较是否是相同节点 key tag，相同节点比较属性,并复用老节点，然后比较儿子节点：
- Vue2 是双端比较，两个列表的头尾相互比较，对比的过程中逐渐向内考虑，直到某一个列表遍历完成。
- Vu3 是头和头比，尾和尾比，剩余的基于最长递增子序列进行增/删/移

### nextTick⭐

- Vue 是异步更新策略，数据变化，vue不会立即更新 dom，是开启一个队列，同一个事件循环里发生的变化会异步的批量更新。
- 要获取到更新后的 dom，需要使用 nextTick，用户传入的回调函数被添加到刷新函数(flushSchedulerQueue)的后面，在dom更新之后执行回调。


### slot实现原理
答案
- 分为普通插槽和作用域插槽
- 普通插槽是在父组件编译和渲染阶段生成 vnodes，所以数据的作用域是父组件实例，子组件渲染的时候直接拿到这些渲染好的 vnodes。
- 作用域插槽，父组件在编译和渲染阶段并不会直接生成 vnodes，而是在父节点 vnode 的 data 中保留一个 scopedSlots 对象，存储着不同名称的插槽以及它们对应的**渲染函数**，只有在编译和渲染子组件阶段才会执行这个渲染函数生成 vnodes，由于是在子组件环境执行的，所以对应的数据作用域是子组件实例。

[https://zhuanlan.zhihu.com/p/126286014](https://zhuanlan.zhihu.com/p/126286014)

### keep-alive⭐

### 谈谈对Vuex的理解⭐


### vue-router⭐
### 

[Vue面试题之vue实现MVVM数据绑定.md](https://github.com/yihan12/day-to-day/blob/master/202101/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8Bvue%E5%AE%9E%E7%8E%B0MVVM%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.md)


# ⭐Webpack
### 构建工具对比
答案
- webpack ：可以打包任何资源，配置略复杂，适合项目开发
- rollup：基于 ES6 的，一般用来打包类库
- vite：打包是基于rollup，dev模式启动快，基于ES module，使用ES build 实时编译

### Webpeck构建流程⭐
答案
- 初始化参数，从配置文件和命令行中读取
- 开始编译，初始化 complier对象，加载插件，开始编译
- 编译模块，从入口文件出发，递归依赖的模块，通过对应的 loader 进行加载编译
- 编译完成后组成 chunk，生成代码，最后输出 bundle
> webpack 会在特定的时间点广播事件，触发所监听事件的插件执行特定的逻辑。


### 什么是Tapable 
答案webpack本质上是一种事件流的机制，compiler 和 complation 都是基于 Tapable 实现的，Tapable 是一种发布订阅的事件系统。

Tapable提供了很多类型的hook，分为同步和异步两大类(异步中又区分异步并行和异步串行)，可进行多种形式的流程控制。

> compiler和 Compilation的区别
> - compiler 可以理解为 webpack 的实例，代表了 webpack 的配置，包括options、loader和plugin
> - compilation 表示一次资源构建过程中的上下文对象。包含这次构建中的全部资源和信息，文件有改动就会重新构建。

###  Loader和Plugin 的不同 ⭐
答案
- webpack 将一起文件都看成模块，通过 loader 可以对文件进行转换
- plugin 可以扩展webpack的功能，作用与整个构建周期，通过监听特定的事件执行特定的逻辑。

常见的 loader 和 plugin
答案loader：

- saas-loader   把 sass 语法转换成 css
- css-loader    分析 css 模块之间的关系，并合成⼀个 css
- style-loader  会把css-loader⽣成的内容，以 style 挂载到⻚⾯
- postcss-loader  使用 autoprefixer 自动添加浏览器前缀
- file-loader  移动静态资源到输出目录
- url-loader  同file-loader 还可以小图转base64
- babel-loader  转义 js 

plugin：

- html-webpack-plugin  ⾃动⽣成html⽂件
- clean-webpack-plugin 默认会删除 output 指定的输出⽬录 
- terser-webpack-plugin 压缩代码
- mini-css-extract-plugin  提取css
- define-plugin  注入全局变量

### loader 怎么写⭐
答案loader 是一个函数，它的参数是匹配到的文件的源码，返回结果是处理后的源码。

- this.callback(null, data) 可通过callback 代替return
- 通过 loader-utils 的 getOptions 方法获取
- 异步处理，通过`this.async`来返回一个异步函数（第一个参数是 Error，第二个参数是处理的结果）

### Plugin 怎么写⭐
答案webpack 在整个编译周期中会触发很多不同的事件，plugin 可以在对应的钩子上注册事件，webpack内部也是通过很多插件实现的。

- 插件一个类，有个apply方法，参数是compiler
- apply 方法内部通 compiler 的 hooks 注册不同时间点的事件

### 异步加载原理
答案
- 查找缓存
- 通过jsonp加载代码，执行回调，是个promise

[https://zhuanlan.zhihu.com/p/88332125](https://zhuanlan.zhihu.com/p/88332125)

### HMR原理⭐
答案
- dev-server 监听编译完成事件，利用ws告诉浏览器的hash和更新模块列表
- 通过jsonp获取更新模块的 js
- 替换先用模块，调用 module.hot.accept() 完成热更新

### Webpack5 新特性⭐
答案
- 内置静态资源构建能力，需要额外的loader
- 持久化缓存，提供二次构建速度
- 模块联邦
> - 使用Module Federation时，应用将被划分为更小的应用块，每个应用块都是一个独立的构建，这些构建都将编译为容器
> - 一个被引用的容器被称为remote, 引用者被称为host



### Tree Shaking 和Scope Hoisting
答案tree shaking：tree shaking 通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块语法的 静态结构 特性，例如 import 和 export。这个概念是从rollup来的。
条件： 

- 生产模式下，启动代码优化，通过 terser 删除dead code
- 引入的包要`package.json`要`sideEffects:false`
- Webpack 中使用 babel-loader 时，建议将 babel-preset-env 的 moduels 配置项设置为 false，关闭模块导入导出语句的转译

Scope Hoisting：

- 分析出模块之间的依赖关系，尽可能的把打散的模块合并到一个函数中去，但前提是不能造成代码冗余。 因此只有那些被引用了一次的模块才能被合并。
- 由于 Scope Hoisting 需要分析出模块之间的依赖关系，因此源码必须采用 ES6 模块化语句，不然它将无法生效。
### hash、chunkhash、contenthash区别
答案
- hash：和整个项目的构建相关，只要有文件修改，hash值就变
- chunkhash：根据chunk生成hash值，根据不同的入口文件
- contenthash：根据内容生成hash值
- js用chunkhash,css用contenhash，图片用contenthash(file-loader的hash是文件内容的)

### 库怎么实现按需加载
答案
- babel-plugin-import 利用babel插件通过生成AST对 import语句，进行转换和生成。
- 比如 import {Button} from 'xxx' 变为 import button from 'xxx/button'

### Source Map最佳实践
答案
### AST和Babel
答案
- 抽象语法树：对代码的一种抽象表示，是树形结构。
- 应用：代码高亮，JS转义，代码压缩，ESLint，Prettier等
- babel 编译 ES5 的过程：parse（解析代码生成AST）、transform（通过 traverse 遍历 AST 进行处理转换）、generator (生成代码)


# ⭐综合
## 性能优化的手段
答案

1. 所谓性能优化，就是从用户请求到页面显示的整个生命周期上的优化。 

大体过程分为：

   - **网络部分**：查找缓存、DNS解析、TCP连接、HTTP请求（会排队）和响应
   - **渲染部分**：浏览器解析渲染
2. 性能优化首先要有指标去评估

3. 优化手段：



**网络请求优化：**
网络请求优化的目标：减少数量和减少单次时间

1. 设置静态资源的 HTTP 缓存（强缓存/协商缓存）
1. 使用 dns-prefetch，进行 DNS 预解析
1. 域名分片、HTTP2（同一个域名最多处理 6 个TCP连接，HTTP请求会排队）
1. preload（预先请求当前页面需要的资源）、 prefetch（将来页面中使用的资源，可能会浪费资源） 将数据缓存到HTTP缓存中
1. 采用 CDN 加速加快访问速度。(指派最近、高度可用)

**静态资源优化：**

- JS/CSS的压缩，减少体积
- 图片相关:
   - 选择合适的格式：jpg/png/svg/webp/gif
   - 响应式图片 （img srcset /  picture source）
   - 小图使用base64，减少请求，还有雪碧图（backgroud-positon）
   - 图片懒加载⚠️

**渲染优化：**
> **渲染过程：**JavaScript处理->计算样式->页面布局->绘制->合成

- JS 阻塞 DOM 解析，使用 async/defer
- CSS选择器减少层数，减少使用通配符。
- 减少重排和重绘

     重排：几何属性、获取某些特定的属性值；重绘：修改样式

   - 合并对 DOM/样式 的操作
   - 脱离文档流
   - 图片定宽高
   - CSS3 的GPU加速（transform/opcity/filter/will-change）
- 使用事件委托
- 事件的防抖和节流
- 使用`webworker`处理长任务、时间切片⚠️
- `requestAnimationFrame`、`requestIdleCallback`
- `IntersectionObserver` 


**构建优化：**

- 速度优化
   - 缩小构建范围
   - 多线程 thread-loader
   - 缓存：
      - terser-webpack-plugin 开启缓存，也可以开启并行
      - babel-loader 开启缓存 
      - 使用 cache-loader ，耗时的 loader之前使用
      - hard-source-webpack-plugin，构建缓存二次构建时间减少80%
- 体积优化
   - 代码压缩
   - 按需加载 import
   - 分包
   - externals 配合，cdn引入

## 有限状态机、parser

有限状态机：根据输入的不同来改为不同的状态
